<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlantis Go - Power Collection Test</title>
  <script src="https://unpkg.com/colyseus.js@^0.14.0/dist/colyseus.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&display=swap">
  <link rel="stylesheet" href="./css/apple-style.css">
  <style>
    :root {
      --primary-color: #007aff;
      --secondary-color: #5856d6;
      --success-color: #34c759;
      --warning-color: #ff9500;
      --danger-color: #ff3b30;
      --light-color: #f2f2f7;
      --dark-color: #1c1c1e;
      --gray-color: #8e8e93;
      --border-radius: 10px;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      
      /* Background and text colors */
      --bg-primary: #f2f2f7;
      --bg-secondary: white;
      --text-primary: #1c1c1e;
      --text-secondary: #48484a;
      --border-color: #d1d1d6;
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-primary: #1c1c1e;
        --bg-secondary: #2c2c2e;
        --text-primary: #ffffff;
        --text-secondary: #ebebf5;
        --border-color: #38383a;
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
        --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3);
        --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
      }
    }
    
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #1e1e1e;
        color: #f0f0f0;
      }
      
      .card {
        background-color: #2d2d2d !important;
        color: #f0f0f0 !important;
        border-color: #444 !important;
      }
      
      button {
        background-color: #0066cc !important;
        color: white !important;
        border-color: #0077dd !important;
      }
      
      button:hover {
        background-color: #0077dd !important;
      }
      
      pre {
        background-color: #2d2d2d !important;
        color: #f0f0f0 !important;
        border-color: #444 !important;
      }
      
      .notification.error {
        background-color: rgba(255, 100, 100, 0.9) !important;
        color: white !important;
      }
      
      .notification.success {
        background-color: rgba(100, 200, 100, 0.9) !important;
        color: white !important;
      }
      
      .log-error {
        color: #ff6b6b !important;
      }
      
      .connection-status {
        border-color: #444 !important;
      }
      
      .connection-status.connected {
        color: #4caf50 !important;
      }
      
      .connection-status.disconnected {
        color: #f44336 !important;
      }
      
      .connection-status.connecting {
        color: #ff9800 !important;
      }
    }
    
    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    
    .section {
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--shadow-sm);
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }
    
    .section-title {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .apple-pill {
      background-color: var(--bg-secondary);
      border-radius: 12px;
      padding: 15px;
      box-shadow: var(--shadow-sm);
      margin-bottom: 10px;
      transition: transform 0.2s, box-shadow 0.2s;
      border: 1px solid var(--border-color);
    }
    
    .apple-pill:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    .btn {
      display: inline-block;
      padding: 10px 15px;
      border-radius: 8px;
      border: none;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      font-size: 14px;
    }
    
    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
    }
    
    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }
    
    .btn-secondary {
      background-color: var(--light-color);
      color: var(--dark-color);
      border: 1px solid var(--border-color);
    }
    
    /* Update secondary button for dark mode */
    @media (prefers-color-scheme: dark) {
      .btn-secondary {
        background-color: #3a3a3c;
        color: white;
        border: 1px solid #505050;
      }
    }
    
    .btn-success {
      background-color: var(--success-color);
      color: white;
    }
    
    .btn-danger {
      background-color: var(--danger-color);
      color: white;
    }
    
    .btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
    
    .btn:active {
      transform: scale(0.98);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .log-container {
      height: 300px;
      overflow-y: auto;
      background-color: var(--bg-primary);
      border-radius: 8px;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid var(--border-color);
    }
    
    .log-entry {
      margin-bottom: 5px;
      padding: 5px;
      border-radius: 4px;
    }
    
    .log-entry.error {
      background-color: rgba(255, 59, 48, 0.1);
      color: var(--danger-color);
    }
    
    .log-entry.warning {
      background-color: rgba(255, 149, 0, 0.1);
      color: var(--warning-color);
    }
    
    .log-timestamp {
      color: var(--gray-color);
      margin-right: 5px;
    }
    
    .log-source {
      font-weight: bold;
      margin-right: 5px;
    }
    
    .debug-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 15px;
    }
    
    .debug-item {
      background-color: var(--bg-primary);
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      border: 1px solid var(--border-color);
    }
    
    .debug-label {
      font-weight: bold;
      margin-bottom: 5px;
      color: var(--gray-color);
    }
    
    .power-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .power-info {
      flex: 1;
    }
    
    .power-name {
      font-weight: bold;
      margin-bottom: 5px;
      color: var(--text-primary);
    }
    
    .power-id {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }
    
    .power-position {
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .action-buttons {
      display: flex;
      gap: 5px;
    }
    
    .empty-message {
      text-align: center;
      padding: 20px;
      color: var(--text-secondary);
      font-style: italic;
      background-color: var(--bg-secondary);
      border-radius: var(--border-radius);
      border: 1px dashed var(--border-color);
      margin: 15px 0;
    }
    
    /* Notification styles - ensure they stand out in dark mode */
    #notification-container .success {
      background-color: var(--success-color);
      color: white;
    }
    
    #notification-container .error {
      background-color: var(--danger-color);
      color: white;
    }
    
    #notification-container .info {
      background-color: var(--primary-color);
      color: white;
    }
    
    /* Spinner for loading states */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      display: inline-block;
      vertical-align: middle;
      margin-right: 5px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Responsive layout */
    @media (max-width: 768px) {
      .container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body class="dark-mode-support">
  <div class="container">
    <div class="section" style="grid-column: 1 / -1;">
      <h2 class="section-title">Power Testing Interface</h2>
      <p>This interface allows you to test power functionality in the game.</p>
      
      <div id="connection-status" class="apple-pill" style="margin-top: 15px; text-align: center; background-color: var(--warning-color); color: white;">
        Connecting...
      </div>
    </div>
    
    <div class="section">
      <h3 class="section-title">Available Powers</h3>
      <button id="btn-spawn-powers" class="btn btn-primary" style="margin-bottom: 15px;">Spawn Test Powers</button>
      <div id="powers-list">
        <div class="empty-message">No powers available. Try spawning some!</div>
      </div>
    </div>
    
    <div class="section" style="grid-column: 1 / -1;">
      <h3 class="section-title">Power Controls</h3>
      <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <button id="btn-spawn-powers" class="btn btn-primary">Spawn Test Powers</button>
        <button id="check-powers-btn" class="btn btn-secondary">Check Current Powers</button>
      </div>
      <div id="power-form" class="power-form" style="display: none;">
        <!-- Custom power spawn form would go here -->
      </div>
    </div>
    
    <div class="section">
      <h3 class="section-title">Debug Console</h3>
      <div id="log-container" class="log-container"></div>
      
      <div id="debug-info" class="debug-info" style="margin-top: 15px;">
        <div class="debug-item">
          <div class="debug-label">Room ID</div>
          <div id="debug-room-id">-</div>
        </div>
        <div class="debug-item">
          <div class="debug-label">Session ID</div>
          <div id="debug-session-id">-</div>
        </div>
        <div class="debug-item">
          <div class="debug-label">Player Position</div>
          <div id="debug-player-position">-</div>
        </div>
        <div class="debug-item">
          <div class="debug-label">Powers Count</div>
          <div id="debug-powers-count">-</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Power Details Modal -->
  <div id="power-modal" class="power-modal">
    <button id="modal-close" class="modal-close">&times;</button>
    <div class="modal-content">
      <h2 id="modal-title" class="modal-title">Power Name</h2>
      <p id="modal-description">Power description goes here.</p>
      
      <div class="modal-stats">
        <div class="stat-item">
          <div class="stat-label">Type</div>
          <div id="modal-type" class="stat-value">Wisdom</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Rarity</div>
          <div id="modal-rarity" class="stat-value">Common</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Matrix Quadrant</div>
          <div id="modal-quadrant" class="stat-value">Soul-Out</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Complexity</div>
          <div id="modal-complexity" class="stat-value">2</div>
        </div>
      </div>
      
      <div id="challenge-container" class="challenge-container">
        <div class="challenge-title">Capture Challenge</div>
        <p id="challenge-description">What virtue does this power represent to you, and why?</p>
        
        <div id="challenge-choice-container" style="display: none;">
          <!-- Choice options will be inserted here -->
        </div>
        
        <div id="challenge-response" class="challenge-response">
          <textarea id="response-text" rows="4" placeholder="Your thoughtful response..."></textarea>
        </div>
      </div>
      
      <div class="modal-actions">
        <button id="btn-cancel-capture" class="btn btn-secondary">Cancel</button>
        <button id="btn-capture" class="btn">Capture Power</button>
      </div>
    </div>
  </div>
  
  <script type="module">
    // Import the PowerCollection component
    import { PowerCollection } from './components/PowerCollection.js';
    import { MasterControlPanel } from './components/MasterControlPanel.js';
    
    // Check if the server is available
    async function checkServerStatus() {
      try {
        const response = await fetch('/');
        if (response.ok) {
          console.log('Server is running');
          return true;
        } else {
          console.error('Server returned an error:', response.status);
          return false;
        }
      } catch (error) {
        console.error('Failed to connect to server:', error);
        document.getElementById('connection-status').textContent = 'Server not available';
        document.getElementById('connection-status').style.backgroundColor = 'var(--danger-color)';
        return false;
      }
    }
    
    // Detect correct server port
    async function detectServerPort() {
      // First try port 3000 (default)
      try {
        const response = await fetch('http://localhost:3000/');
        if (response.ok) {
          console.log('Server detected on port 3000');
          return 3000;
        }
      } catch (e) {
        console.log('Server not found on port 3000');
      }
      
      // Try port 2567 (alternative)
      try {
        const response = await fetch('http://localhost:2567/');
        if (response.ok) {
          console.log('Server detected on port 2567');
          return 2567;
        }
      } catch (e) {
        console.log('Server not found on port 2567');
      }
      
      // Default to 3000 if we can't detect
      return 3000;
    }
    
    // Main app class for power testing
    class PowerTestApp {
      constructor() {
        this.client = null;
        this.room = null;
        this.connected = false;
        this.lastPowerCount = 0;
        
        // Initialize UI
        this.initUI();
        
        // Connect to server automatically
        this.connect();
        
        // Log initialization
        this.log('System', 'Power testing interface initialized');
      }
      
      initUI() {
        // Connection status
        this.connectionStatus = document.getElementById('connection-status');
        
        // Buttons
        this.spawnButton = document.getElementById('btn-spawn-powers');
        this.spawnButton.addEventListener('click', () => this.spawnTestPowers());
        this.spawnButton.disabled = true; // Disabled until connected
        
        // Powers list
        this.powersList = document.getElementById('powers-list');
        
        // Log container
        this.logContainer = document.getElementById('log-container');
        
        // Debug elements
        this.debugRoomId = document.getElementById('debug-room-id');
        this.debugSessionId = document.getElementById('debug-session-id');
        this.debugPlayerPosition = document.getElementById('debug-player-position');
        this.debugPowersCount = document.getElementById('debug-powers-count');
        
        // Initialize with empty state
        this.updateDebugInfo();
      }
      
      async connect() {
        this.updateConnectionStatus('connecting...');
        this.log('Connection', 'Attempting to connect to server...');
        
        try {
          // First check if server is available
          const serverAvailable = await checkServerStatus();
          if (!serverAvailable) {
            this.updateConnectionStatus('disconnected');
            this.log('Error', 'Server not available. Please make sure the server is running.', true);
            this.showNotification('Server not available. Please start the server.', 'error');
            return;
          }
          
          // Detect the correct port
          const port = await detectServerPort();
          
          // Create client with correct port 
          const protocol = window.location.protocol.replace('http', 'ws');
          const endpoint = `${protocol}//${window.location.hostname}:${port}`;
          
          console.log('Connecting to:', endpoint);
          this.client = new Colyseus.Client(endpoint);
          
          // Join room with correct room name ("world" instead of "atlantis")
          await this.client.joinOrCreate('world', {
            username: `Tester_${Math.floor(Math.random() * 1000)}`,
            position: { 
              x: (Math.random() * 20) - 10,  // Random position near origin
              y: (Math.random() * 20) - 10   // for testing
            }
          })
            .then(room => {
              console.log('Joined room:', room);
              this.room = room;
              this.connected = true;
              this.updateConnectionStatus('connected');
              this.log('Connection', 'Connected to server successfully');
              
              // Set up room event handlers
              this.setupRoomHandlers();
              
              // Update UI
              this.updateAvailablePowers();
              this.updateDebugInfo();
              
              // Enable spawn button
              this.spawnButton.disabled = false;
              
              // Show notification
              this.showNotification('Connected to server', 'success');
            })
            .catch(error => {
              console.error('Room join error:', error);
              this.updateConnectionStatus('disconnected');
              this.log('Error', `Connection failed: ${error.message}`, true);
              
              // Show notification
              this.showNotification(`Connection failed: ${error.message}`, 'error');
            });
        } catch (error) {
          console.error('Client creation error:', error);
          this.updateConnectionStatus('disconnected');
          this.log('Error', `Client error: ${error.message}`, true);
          
          // Show notification
          this.showNotification(`Client error: ${error.message}`, 'error');
        }
      }
      
      setupRoomHandlers() {
        if (!this.room) return;
        
        // Handle room state changes
        this.room.onStateChange(() => {
          console.log('Room state changed');
          this.updateAvailablePowers();
          this.updateDebugInfo();
        });
        
        // Handle when the room is disconnected
        this.room.onLeave((code) => {
          console.log('Room left:', code);
          this.connected = false;
          this.updateConnectionStatus('disconnected');
          this.log('Connection', `Disconnected from server (code: ${code})`);
          this.showNotification('Disconnected from server', 'error');
        });
        
        // Handle errors
        this.room.onError((code, message) => {
          console.error('Room error:', code, message);
          this.log('Error', `Room error: ${code} - ${message}`, true);
          this.showNotification(`Room error: ${message}`, 'error');
        });
        
        // Listen for admin power spawn events (server sends this)
        this.room.onMessage('admin:powersSpawned', (message) => {
          console.log('Powers spawned:', message);
          this.log('Admin', `Spawned ${message.count} powers at radius ${message.radius}m`);
          
          // Reset the spawn button
          const button = document.getElementById('btn-spawn-powers');
          if (button) {
            button.innerHTML = 'Spawn Test Powers';
            button.disabled = false;
          }
          
          // Update UI
          this.updateAvailablePowers();
          this.showNotification(`Successfully spawned ${message.count} powers!`, 'success');
        });
        
        // Listen for power details
        this.room.onMessage('power:details', (message) => {
          console.log('Power details received:', message);
          this.log('Power', `Received details for power: ${message.name || message.id}`);
        });
        
        // Listen for power spawn events (fallback)
        this.room.onMessage('powerSpawned', (message) => {
          console.log('Power spawned:', message);
          this.log('Power', `New power spawned: ${message.type || 'Unknown'}`);
          this.updateAvailablePowers();
          this.showNotification('New power spawned!', 'success');
        });
        
        // Listen for power collected events
        this.room.onMessage('powerCollected', (message) => {
          console.log('Power collected:', message);
          this.log('Power', `Power collected: ${message.powerId}`);
          this.updateAvailablePowers();
          this.showNotification('Power collected!', 'success');
        });
        
        // Listen for power deleted events
        this.room.onMessage('powerDeleted', (message) => {
          console.log('Power deleted:', message);
          this.log('Power', `Power deleted: ${message.powerId}`);
          this.updateAvailablePowers();
          this.showNotification('Power deleted', 'info');
        });
        
        // Listen for all other messages for debugging
        this.room.onMessage('*', (type, message) => {
          if (type !== 'powerSpawned' && 
              type !== 'powerCollected' && 
              type !== 'powerDeleted' && 
              type !== 'power:details' && 
              type !== 'admin:powersSpawned') {
            console.log(`Received unknown message type: ${type}`, message);
            this.log('Message', `Received ${type} message`);
          }
        });
      }
      
      initPowerCollection() {
        // Now create our power collection and hook it up
        const container = document.body;
        this.powerCollection = new PowerCollection(container, this.room);
        
        // Initial collection update
        this.updatePlayerStats();
        this.updateCollectionPowers();
      }
      
      /**
       * Disconnect from the server
       */
      disconnect() {
        if (this.room) {
          this.log('Connection', 'Disconnecting from server...');
          this.room.leave();
          this.room = null;
        }
        
        if (this.client) {
          this.client = null;
        }
        
        this.connected = false;
        this.updateConnectionStatus('disconnected');
        this.log('Connection', 'Disconnected from server');
        this.showNotification('Disconnected from server', 'info');
        
        // Update UI
        this.spawnButton.disabled = true;
        this.updateDebugInfo();
      }
      
      updateConnectionStatus(status) {
        if (!this.connectionStatus) return;
        
        this.connectionStatus.textContent = status;
        
        // Update styles based on status
        this.connectionStatus.style.backgroundColor = '';
        
        switch (status.toLowerCase()) {
          case 'connected':
            this.connectionStatus.style.backgroundColor = 'var(--success-color)';
            this.spawnButton.disabled = false;
            break;
          case 'connecting...':
            this.connectionStatus.style.backgroundColor = 'var(--warning-color)';
            this.spawnButton.disabled = true;
            break;
          case 'disconnected':
            this.connectionStatus.style.backgroundColor = 'var(--danger-color)';
            this.spawnButton.disabled = true;
            break;
          default:
            this.connectionStatus.style.backgroundColor = 'var(--gray-color)';
            this.spawnButton.disabled = true;
        }
      }
      
      updateDebugInfo() {
        if (!this.room || !this.room.state) {
          this.debugRoomId.textContent = '-';
          this.debugSessionId.textContent = '-';
          this.debugPlayerPosition.textContent = '-';
          this.debugPowersCount.textContent = '-';
          return;
        }
        
        // Update room ID
        this.debugRoomId.textContent = this.room.id || '-';
        
        // Update session ID
        this.debugSessionId.textContent = this.room.sessionId || '-';
        
        // Update player position
        const player = this.room.state.players.get(this.room.sessionId);
        if (player) {
          const x = Math.round(player.x);
          const y = Math.round(player.y);
          this.debugPlayerPosition.textContent = `(${x}, ${y})`;
        } else {
          this.debugPlayerPosition.textContent = 'Player not found';
        }
        
        // Update powers count
        const powers = this.room.state.powers;
        if (powers) {
          this.debugPowersCount.textContent = `${powers.size} total`;
        } else {
          this.debugPowersCount.textContent = 'Powers not found';
        }
      }
      
      /**
       * Update the list of available powers from the room state
       */
      updateAvailablePowers() {
        const powersList = document.getElementById('powers-list');
        powersList.innerHTML = '';
        
        if (!this.room || !this.room.state) {
          console.warn('Cannot update powers: room or state is not available');
          return;
        }
        
        // Get the powers from the room state
        const powers = this.room.state.powers;
        
        if (!powers) {
          console.warn('Powers collection not found in room state');
          this.log('Warning', 'Powers collection not found in room state', true);
          return;
        }
        
        console.log(`Found ${powers.size} powers in state`);
        this.log('Info', `Found ${powers.size} powers in state`);
        
        if (powers.size === 0) {
          const emptyMessage = document.createElement('div');
          emptyMessage.className = 'empty-message';
          emptyMessage.textContent = 'No powers available. Try spawning some!';
          powersList.appendChild(emptyMessage);
          return;
        }
        
        // Create a fragment to improve performance
        const fragment = document.createDocumentFragment();
        
        // Track if we've added any powers to the UI
        let powersAdded = 0;
        
        // Convert to array and sort by ID for consistent display
        const powersArray = Array.from(powers.entries());
        powersArray.sort((a, b) => a[0].localeCompare(b[0]));
        
        powersArray.forEach(([id, power]) => {
          try {
            // Skip powers that don't have necessary properties
            if (!power || typeof power !== 'object') {
              console.warn(`Power ${id} is not a valid object:`, power);
              return;
            }
            
            // Create power item
            const powerItem = document.createElement('div');
            powerItem.className = 'power-item apple-pill';
            powerItem.dataset.powerId = id;
            
            // Power info
            const powerInfo = document.createElement('div');
            powerInfo.className = 'power-info';
            
            // Power name/type
            const powerName = document.createElement('div');
            powerName.className = 'power-name';
            powerName.textContent = power.type || 'Unknown Power';
            
            // Power ID (truncated)
            const powerIdElem = document.createElement('div');
            powerIdElem.className = 'power-id';
            powerIdElem.textContent = `ID: ${id.substring(0, 8)}...`;
            powerIdElem.title = id;
            
            // Power position
            const powerPosition = document.createElement('div');
            powerPosition.className = 'power-position';
            const posX = power.x !== undefined ? Math.round(power.x) : '?';
            const posY = power.y !== undefined ? Math.round(power.y) : '?';
            powerPosition.textContent = `Position: (${posX}, ${posY})`;
            
            // Add info to power item
            powerInfo.appendChild(powerName);
            powerInfo.appendChild(powerIdElem);
            powerInfo.appendChild(powerPosition);
            powerItem.appendChild(powerInfo);
            
            // Add a click handler to view power details
            powerItem.addEventListener('click', (e) => {
              // Only trigger if not clicking buttons
              if (!e.target.closest('button')) {
                this.viewPowerDetails(id);
              }
            });
            
            // Add action buttons
            const actionButtons = document.createElement('div');
            actionButtons.className = 'action-buttons';
            
            // Collect button
            const collectButton = document.createElement('button');
            collectButton.className = 'btn btn-small btn-primary';
            collectButton.textContent = 'Collect';
            collectButton.onclick = () => this.collectPower(id);
            
            // Delete button
            const deleteButton = document.createElement('button');
            deleteButton.className = 'btn btn-small btn-danger';
            deleteButton.textContent = 'Delete';
            deleteButton.onclick = () => this.deletePower(id);
            
            // Add buttons to container
            actionButtons.appendChild(collectButton);
            actionButtons.appendChild(deleteButton);
            powerItem.appendChild(actionButtons);
            
            // Add to fragment
            fragment.appendChild(powerItem);
            powersAdded++;
          } catch (error) {
            console.error(`Error rendering power ${id}:`, error);
          }
        });
        
        // Add the fragment to the list
        powersList.appendChild(fragment);
        
        // Show notification if powers were added
        if (powersAdded > 0 && this.lastPowerCount !== powersAdded) {
          this.showNotification(`${powersAdded} powers available`, 'success');
        }
        
        // Update last count
        this.lastPowerCount = powersAdded;
        
        // Update debug info
        this.updateDebugInfo();
      }
      
      updateCollectionPowers() {
        if (!this.room || !this.room.state || !this.room.state.players) {
          return;
        }
        
        // Get current player
        const player = this.room.state.players.get(this.room.sessionId);
        if (!player) return;
        
        // Clear container
        this.collectionPowersContainer.innerHTML = '';
        
        // Check if player has powers
        if (!player.powers || player.powers.size === 0) {
          this.collectionPowersContainer.innerHTML = '<div class="no-powers">You haven\'t collected any powers yet</div>';
          return;
        }
        
        // Add each power
        player.powers.forEach((power, powerId) => {
          const powerElement = document.createElement('div');
          powerElement.className = 'collection-item';
          
          powerElement.innerHTML = `
            <div class="collection-icon ${power.rarity.toLowerCase()}">${power.type.charAt(0)}</div>
            <div class="collection-details">
              <div class="power-name">${power.name || 'Unknown Power'}</div>
              <div class="power-description">${power.type || ''} (${power.rarity})</div>
            </div>
          `;
          
          this.collectionPowersContainer.appendChild(powerElement);
        });
      }
      
      updatePlayerStats() {
        if (!this.room || !this.room.state || !this.room.state.players) {
          return;
        }
        
        // Get current player
        const player = this.room.state.players.get(this.room.sessionId);
        if (!player) return;
        
        // Update stats
        const powerCount = player.powers ? player.powers.size : 0;
        this.statPowers.textContent = powerCount;
        this.statRank.textContent = player.rank || 1;
        this.statXP.textContent = player.xp || 0;
        
        // Update collection
        this.updateCollectionPowers();
      }
      
      interactWithPower(powerId) {
        if (!this.room) {
          console.error('Cannot interact with power: room is not connected');
          this.log('Error', 'Not connected to server', true);
          return;
        }
        
        // Validate power ID
        if (!powerId) {
          console.error('Invalid power ID:', powerId);
          this.log('Error', 'Invalid power ID', true);
          return;
        }
        
        console.log('Interacting with power:', powerId);
        this.log('Power', `Interacting with power: ${powerId}`);
        
        // Update debug info
        this.debugServer.textContent = `Sending request for power: ${powerId}`;
        
        try {
          // Wrap the interaction in a clearer message format
          const message = { 
            powerId: powerId,
            clientTime: Date.now()
          };
          
          console.log('Sending power:interact message:', message);
          this.room.send('power:interact', message);
          
          // Add a timeout to detect if we don't get a response
          setTimeout(() => {
            // Check if we're still waiting (modal not opened)
            if (this.powerModal.style.display !== 'flex') {
              console.warn('No response received for power interaction', powerId);
              this.log('Warning', 'No response from server after 5 seconds', true);
            }
          }, 5000);
          
        } catch (error) {
          console.error('Error sending power:interact message:', error);
          this.log('Error', `Failed to send interaction: ${error.message}`, true);
          this.debugServer.textContent = `Error: ${error.message}`;
        }
      }
      
      showPowerDetails(power) {
        if (!power) {
          console.error('Received empty power details');
          this.log('Error', 'Received empty power details', true);
          return;
        }
        
        console.log('Showing power details:', power);
        this.currentPower = power;
        
        // Set modal content
        this.modalTitle.textContent = power.name || 'Unknown Power';
        this.modalDescription.textContent = power.description || 'No description available.';
        this.modalType.textContent = power.type || 'Unknown';
        this.modalRarity.textContent = power.rarity || 'Common';
        this.modalQuadrant.textContent = power.matrixQuadrant || 'Unknown';
        this.modalComplexity.textContent = power.complexity || '1';
        
        // Set up challenge
        if (power.captureChallenge) {
          const challenge = power.captureChallenge;
          
          if (challenge.type === 'choice') {
            // Set up multiple choice
            this.challengeDescription.textContent = challenge.scenario || 'Make your choice:';
            this.challengeChoiceContainer.innerHTML = '';
            this.challengeChoiceContainer.style.display = 'block';
            
            // Add choice options
            if (challenge.options && Array.isArray(challenge.options)) {
              challenge.options.forEach((option, index) => {
                const choiceElement = document.createElement('div');
                choiceElement.className = 'challenge-choice';
                choiceElement.innerHTML = `
                  <input type="radio" name="choice" value="${index}" id="choice-${index}">
                  <label for="choice-${index}">${option}</label>
                `;
                this.challengeChoiceContainer.appendChild(choiceElement);
              });
            }
            
            // Hide text response
            document.getElementById('challenge-response').style.display = 'none';
          } else {
            // Text-based challenge
            this.challengeDescription.textContent = challenge.question || challenge.prompt || 'What virtue does this power represent to you?';
            this.challengeChoiceContainer.style.display = 'none';
            document.getElementById('challenge-response').style.display = 'block';
          }
        } else {
          // No challenge defined, use default
          this.challengeDescription.textContent = 'What virtue does this power represent to you?';
          this.challengeChoiceContainer.style.display = 'none';
          document.getElementById('challenge-response').style.display = 'block';
        }
        
        // Show modal
        this.powerModal.style.display = 'flex';
      }
      
      closeModal() {
        this.powerModal.style.display = 'none';
        this.currentPower = null;
      }
      
      capturePower() {
        if (!this.currentPower || !this.room) {
          console.error('No power selected or room not connected');
          this.log('Error', 'Cannot capture: no power selected or room not connected', true);
          return;
        }
        
        console.log('Attempting to capture power:', this.currentPower);
        this.log('Power', `Attempting to capture power: ${this.currentPower.name || this.currentPower.id}`);
        
        // Prepare response data
        const response = {
          text: this.responseText.value,
          choiceIndex: -1,
          clientTime: Date.now(),
          powerId: this.currentPower.id
        };
        
        // Get choice selection if applicable
        if (this.currentPower.captureChallenge && this.currentPower.captureChallenge.type === 'choice') {
          const selected = document.querySelector('input[name="choice"]:checked');
          response.choiceIndex = selected ? parseInt(selected.value) : -1;
        } else {
          // Validate text response
          if (!response.text || response.text.trim().length < 10) {
            this.log('Error', 'Please provide a thoughtful response (at least 10 characters)', true);
            return;
          }
        }
        
        console.log('Sending capture response:', response);
        
        // Update button state
        const captureButton = document.getElementById('btn-capture');
        const originalText = captureButton.textContent;
        captureButton.textContent = 'Capturing...';
        captureButton.disabled = true;
        
        try {
          // Send capture request
          this.room.send('power:capture', response);
          
          // Set timeout to restore button if no response
          setTimeout(() => {
            if (captureButton.disabled) {
              captureButton.textContent = originalText;
              captureButton.disabled = false;
              this.log('Warning', 'No response received for capture request', true);
            }
          }, 5000);
        } catch (error) {
          console.error('Error sending capture request:', error);
          this.log('Error', `Failed to send capture: ${error.message}`, true);
          captureButton.textContent = originalText;
          captureButton.disabled = false;
        }
      }
      
      spawnTestPowers() {
        if (!this.room) {
          console.error('Cannot spawn powers: room is not connected');
          this.log('Error', 'Not connected to server', true);
          return;
        }
        
        console.log('Requesting test power spawn');
        this.log('Admin', 'Requesting test power spawn');
        
        // Show a spinner in the button
        const button = document.getElementById('btn-spawn-powers');
        const originalText = button.textContent;
        button.innerHTML = '<div class="spinner"></div> Spawning...';
        button.disabled = true;
        
        try {
          // Get player position
          const player = this.room.state.players.get(this.room.sessionId);
          const position = player ? { x: player.x, y: player.y } : { x: 0, y: 0 };
          
          // Create the spawn request
          const spawnRequest = {
            count: 10, // Increased count for more powers
            nearPlayer: true,
            radius: 500, // Larger radius so they're easier to find
            position: position
          };
          
          // Log the request details
          console.log('Sending spawn request:', spawnRequest);
          
          // Try sending the message directly without checking listeners
          // First try the debugSpawnTestPowers message (preferred)
          this.room.send('debug:spawnTestPowers', spawnRequest);
          
          // As a fallback, also try the admin:spawnPowers message for older server versions
          setTimeout(() => {
            this.room.send('admin:spawnPowers', spawnRequest);
          }, 500);
          
          // Set up a timeout to re-enable the button if no response
          setTimeout(() => {
            if (button.disabled) {
              console.log('No response received for power spawn request');
              button.innerHTML = originalText;
              button.disabled = false;
              this.log('Warning', 'No response from server about power spawning', true);
              
              // Manually check powers in the state
              if (this.room && this.room.state && this.room.state.powers) {
                console.log('Current powers in state:', this.room.state.powers.size);
                
                // Force update regardless to see if powers exist but UI isn't updating
                this.updateAvailablePowers();
                this.updateDebugInfo();
              }
            }
          }, 5000);
        } catch (error) {
          console.error('Error spawning powers:', error);
          this.log('Error', `Failed to spawn powers: ${error.message}`, true);
          button.innerHTML = originalText;
          button.disabled = false;
        }
      }
      
      log(category, message, isError = false) {
        const now = new Date();
        const time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
        
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${isError ? 'log-error' : ''}`;
        logEntry.innerHTML = `
          <span class="log-time">[${time}]</span>
          <span class="log-event">[${category}]</span>
          <span class="log-message">${message}</span>
        `;
        
        this.logContainer.appendChild(logEntry);
        this.logContainer.scrollTop = this.logContainer.scrollHeight;
      }
      
      /**
       * Show a notification message
       * @param {string} message - Message to display
       * @param {string} type - Type of notification (success, error, info)
       */
      showNotification(message, type = 'info') {
        // Create notification element if it doesn't exist
        let notificationContainer = document.getElementById('notification-container');
        
        if (!notificationContainer) {
          notificationContainer = document.createElement('div');
          notificationContainer.id = 'notification-container';
          notificationContainer.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 90%;
            width: 400px;
          `;
          document.body.appendChild(notificationContainer);
        }
        
        // Create notification
        const notification = document.createElement('div');
        notification.className = `apple-pill ${type}`;
        notification.textContent = message;
        notification.style.cssText = `
          padding: 12px 20px;
          animation: fadeInDown 0.3s ease-out forwards;
          width: 100%;
          text-align: center;
          box-shadow: var(--shadow-md);
        `;
        
        // Add animation keyframes if they don't exist
        if (!document.getElementById('notification-keyframes')) {
          const style = document.createElement('style');
          style.id = 'notification-keyframes';
          style.textContent = `
            @keyframes fadeInDown {
              from { opacity: 0; transform: translateY(-20px); }
              to { opacity: 1; transform: translateY(0); }
            }
            
            @keyframes fadeOut {
              from { opacity: 1; }
              to { opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }
        
        // Add to container
        notificationContainer.appendChild(notification);
        
        // Remove after delay
        setTimeout(() => {
          notification.style.animation = 'fadeOut 0.3s ease-out forwards';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }, 3000);
      }
      
      /**
       * Collect a power
       * @param {string} powerId - ID of the power to collect
       */
      collectPower(powerId) {
        if (!this.room || !powerId) {
          this.log('Error', 'Cannot collect power: room not connected or invalid ID', true);
          this.showNotification('Failed to collect power: not connected', 'error');
          return;
        }
        
        this.log('Action', `Attempting to collect power: ${powerId}`);
        
        // Send message to the server
        this.room.send('collectPower', { powerId });
        
        // Show notification
        this.showNotification(`Attempting to collect power ${powerId.substring(0, 8)}...`, 'info');
      }
      
      /**
       * Delete a power
       * @param {string} powerId - ID of the power to delete
       */
      deletePower(powerId) {
        if (!this.room || !powerId) {
          this.log('Error', 'Cannot delete power: room not connected or invalid ID', true);
          this.showNotification('Failed to delete power: not connected', 'error');
          return;
        }
        
        this.log('Action', `Attempting to delete power: ${powerId}`);
        
        // Send message to the server
        this.room.send('deletePower', { powerId });
        
        // Show notification
        this.showNotification(`Deleting power ${powerId.substring(0, 8)}...`, 'info');
      }
      
      /**
       * View details of a power
       * @param {string} powerId - ID of the power to view
       */
      viewPowerDetails(powerId) {
        if (!this.room) {
          this.showNotification('Not connected to server', 'error');
          return;
        }
        
        try {
          console.log(`Viewing details for power: ${powerId}`);
          this.log('Power', `Requesting details for power: ${powerId}`);
          
          // Request power details
          this.room.send('power:details', { 
            powerId,
            clientTime: Date.now() 
          });
          
          // Show notification
          this.showNotification('Requesting power details...', 'info');
        } catch (error) {
          console.error('Error requesting power details:', error);
          this.log('Error', `Failed to request power details: ${error.message}`, true);
          this.showNotification(`Failed to request power details: ${error.message}`, 'error');
        }
      }

      logRoomListeners() {
        // Safety check to prevent errors
        if (!this.room || !this.room.listeners) {
          this.log('Debug', 'Room or listeners not available', false);
          return;
        }
        
        this.log('Debug', `Room listeners: ${Object.keys(this.room.listeners).join(', ')}`, false);
      }

      onRoomJoin(room) {
        this.room = room;
        this.updateConnectionStatus('connected');
        this.showNotification('Connected to server successfully!', 'success');
        this.log('Connection', 'Connected to room: ' + room.name);
        
        // Log room event listeners
        this.logRoomListeners();
        
        // Listen for room state changes
        room.state.listen("powers", (powers) => {
          this.renderPowers(powers);
        });
        
        // Listen for spawn power messages
        room.onMessage("powerSpawned", (message) => {
          this.log('Server', `New power spawned: ${message.type} at position (${message.position.x.toFixed(2)}, ${message.position.y.toFixed(2)})`, false);
          this.showNotification(`New power spawned: ${message.type}`, 'success');
        });
        
        // Listen for spawn error messages
        room.onMessage("spawnError", (message) => {
          this.log('Error', `Spawn error: ${message.error}`, true);
          this.showNotification(`Spawn error: ${message.error}`, 'error');
        });
        
        // Log other messages
        room.onMessage("*", (type, message) => {
          if (type !== "powerSpawned" && type !== "spawnError") {
            this.log('Server', `Received message of type: ${type}`, false);
            console.log("Message:", message);
          }
        });
        
        // Listen for disconnection
        room.onLeave((code) => {
          this.room = null;
          this.updateConnectionStatus('disconnected');
          this.log('Connection', `Disconnected from room: ${code}`, true);
          this.showNotification('Disconnected from server', 'error');
        });
      }

      checkCurrentPowers() {
        if (!this.room) {
          this.showNotification('Not connected to server', 'error');
          return;
        }
        
        this.log('Action', 'Requesting current powers from server');
        
        // Send a message to the server to get current powers
        this.room.send('checkPowers');
        
        // Show the current powers in the state (backup if server doesn't respond)
        if (this.room.state.powers) {
          const powers = this.room.state.powers;
          const powerCount = powers.size;
          this.log('Debug', `Current powers in state: ${powerCount}`);
          this.renderPowers(powers);
        } else {
          this.log('Debug', 'No powers in room state');
          this.renderPowers(null);
        }
      }

      renderPowers(powers) {
        const powersList = document.getElementById('powers-list');
        if (!powersList) return;
        
        // Clear the existing list
        powersList.innerHTML = '';
        
        if (!powers || powers.size === 0) {
          // Show empty message when no powers are available
          const emptyDiv = document.createElement('div');
          emptyDiv.className = 'empty-message';
          emptyDiv.textContent = 'No powers currently available in the game.';
          powersList.appendChild(emptyDiv);
          return;
        }
        
        // Create a document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Loop through powers and create UI elements
        powers.forEach((power, id) => {
          try {
            // Create power item element
            const powerItem = document.createElement('div');
            powerItem.className = 'apple-pill power-item';
            powerItem.dataset.powerId = id;
            
            // Get position and type
            const posX = power.x !== undefined ? parseFloat(power.x).toFixed(2) : '?';
            const posY = power.y !== undefined ? parseFloat(power.y).toFixed(2) : '?';
            const powerType = power.type || 'Unknown';
            
            // Create the content
            powerItem.innerHTML = `
              <div class="power-info">
                <div class="power-name">${powerType}</div>
                <div class="power-id" title="${id}">ID: ${id.substring(0, 8)}...</div>
                <div class="power-position">Position: (${posX}, ${posY})</div>
              </div>
              <div class="action-buttons">
                <button class="btn btn-small btn-primary collect-btn">Collect</button>
                <button class="btn btn-small btn-danger delete-btn">Delete</button>
              </div>
            `;
            
            // Add event listeners for buttons
            const collectBtn = powerItem.querySelector('.collect-btn');
            if (collectBtn) {
              collectBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.collectPower(id);
              });
            }
            
            const deleteBtn = powerItem.querySelector('.delete-btn');
            if (deleteBtn) {
              deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deletePower(id);
              });
            }
            
            // Add to fragment
            fragment.appendChild(powerItem);
          } catch (error) {
            console.error(`Error rendering power ${id}:`, error);
            this.log('Error', `Failed to render power ${id}: ${error.message}`, true);
          }
        });
        
        // Add all elements to the list
        powersList.appendChild(fragment);
        
        // Update the count
        const count = powers.size;
        this.log('Info', `Rendered ${count} powers in the list`);
        
        // Update debug info if available
        if (this.updateDebugInfo) {
          this.updateDebugInfo();
        }
      }

      spawnPower() {
        if (!this.room) {
          this.log('Error', 'Cannot spawn power: not connected to server', true);
          this.showNotification('Not connected to server', 'error');
          return;
        }
        
        try {
          // Get form values
          const type = document.getElementById('power-type').value || 'speed';
          const x = parseFloat(document.getElementById('power-position-x').value) || 0;
          const y = parseFloat(document.getElementById('power-position-y').value) || 0;
          const duration = parseInt(document.getElementById('power-duration').value) || 10;
          
          // Log the action
          this.log('Action', `Attempting to spawn power: ${type} at (${x}, ${y}), duration: ${duration}s`);
          
          // Create the power object
          const power = {
            type,
            position: { x, y },
            duration: duration * 1000 // Convert to milliseconds
          };
          
          // Send message to server
          this.room.send('spawnPower', power);
          
          // Show notification
          this.showNotification(`Spawning ${type} power...`, 'info');
        } catch (error) {
          console.error('Error spawning power:', error);
          this.log('Error', `Failed to spawn power: ${error.message}`, true);
          this.showNotification(`Failed to spawn power: ${error.message}`, 'error');
        }
      }
    }
    
    // Initialize app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.app = new PowerTestApp();
      document.getElementById('connect-btn').addEventListener('click', async () => await window.app.connect());
      document.getElementById('disconnect-btn').addEventListener('click', () => window.app.disconnect());
      document.getElementById('spawn-power-btn').addEventListener('click', () => window.app.spawnPower());
      document.getElementById('check-powers-btn').addEventListener('click', () => window.app.checkCurrentPowers());
    });
  </script>
</body>
</html> 